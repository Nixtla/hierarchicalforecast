---
output-file: methods.html
title: Reconciliation Methods
---


In hierarchical forecasting, we aim to create forecasts for many time
series concurrently, whilst adhering to pre-specified hierarchical
relationships that exist between the time series. We can enforce this
coherence by performing a post-processing reconciliation step on the
forecasts.

The `HierarchicalForecast` package provides the most comprehensive
collection of Python implementations of hierarchical forecasting
algorithms that follow classic hierarchical reconciliation. All the
methods have a `reconcile` function capable of reconciling base
forecasts using `numpy` arrays.

## Cross-sectional hierarchies

Traditionally, hierarchical forecasting methods reconcile
*cross-sectional* aggregations. For example, we may have forecasts for
individual product demand, but also for the overall product group,
department and store, and we are interested in making sure these
forecasts are coherent with each other. This can be formalized as:

$$\tilde{\textbf{Y}} = SP\hat{\textbf{Y}} \;, $$

where \$ ^{m p} \$ denotes the matrix of forecasts for all $m$ time
series for all $p$ time steps in the hierarchy,
$S \in \lbrace0, 1\rbrace^{m \times n}$ is a matrix that defines the
hierarchical relationship between the $n$ bottom-level time series and
the $m^* = m - n$ aggregations, $P \in \mathbb{R}^{n \times m}$ is a
matrix that encapsulates the contribution of each forecast to the final
estimate, and $\tilde{\textbf{Y}} \in \mathbb{R}^{m \times p}$ is the
matrix of reconciled forecasts. We can use the matrix $P$ to define
various forecast contribution scenarios.

Cross-sectional reconciliation methods aim to find the optimal $P$
matrix.

## Temporal hierarchies

We can also perform *temporal* reconciliation. For example, we may have
forecasts for daily demand, weekly, and monthly, and we are interested
in making sure these forecasts are coherent with each other. We
formalize the temporal hierarchical forecasting problem as:

$$\tilde{\textbf{Y}} = \left( S_{te} P_{te} \hat{\textbf{Y}}^{\intercal} \right)^{\intercal}  \;, $$

where $S_{te} \in \lbrace0, 1\rbrace^{p \times k}$ is a matrix that
defines the hierarchical relationship between the $k$ bottom-level time
steps and the $p^* = p - k$ aggregations and
$P_{te} \in \mathbb{R}^{k \times p}$ is a matrix that encapsulates the
contribution of each forecast to the final estimate. We can use the
matrix $P_{te}$ to define various forecast contribution scenarios.

Temporal reconciliation methods aim to find the optimal $P_{te}$ matrix.

## Cross-temporal reconciliation

We can combine cross-sectional and temporal hierarchical forecasting by
performing cross-sectional reconciliation and temporal reconciliation in
a two-step procedure.

**References**<br/> -[Hyndman, Rob. Notation for forecast
reconciliation.](https://robjhyndman.com/hyndsight/reconciliation-notation.html)<br/>

# 1. Bottom-Up

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L163"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUp

> ``` text
>  BottomUp ()
> ```

\*Bottom Up Reconciliation Class. The most basic hierarchical
reconciliation is performed using an Bottom-Up strategy. It was proposed
for the first time by Orcutt in 1968. The corresponding hierarchical
“projection” matrix is defined as:
$$\mathbf{P}_{\text{BU}} = [\mathbf{0}_{\mathrm{[b],[a]}}\;|\;\mathbf{I}_{\mathrm{[b][b]}}]$$

**Parameters:**<br/> None

**References:**<br/> - [Orcutt, G.H., Watts, H.W., & Edwards, J.B.(1968).
“Data aggregation and information loss”. The American Economic Review,
58 , 773(787)](http://www.jstor.org/stable/1815532).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L189"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUp.fit

> ``` text
>  BottomUp.fit (S:numpy.ndarray, y_hat:numpy.ndarray,
>                idx_bottom:numpy.ndarray,
>                y_insample:Optional[numpy.ndarray]=None,
>                y_hat_insample:Optional[numpy.ndarray]=None,
>                sigmah:Optional[numpy.ndarray]=None,
>                intervals_method:Optional[str]=None,
>                num_samples:Optional[int]=None, seed:Optional[int]=None,
>                tags:Optional[dict[str,numpy.ndarray]]=None)
> ```

\*Bottom Up Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: In-sample values of size (`base`, `horizon`).<br/>
`y_hat_insample`: In-sample forecast values of size (`base`,
`horizon`).<br/> `sigmah`: Estimated standard deviation of the
conditional marginal distribution.<br/>  
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `**sampler_kwargs`: Coherent sampler instantiation
arguments.<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUp.predict

> ``` text
>  BottomUp.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                    level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L237"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUp.fit_predict

> ``` text
>  BottomUp.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                        idx_bottom:numpy.ndarray,
>                        y_insample:Optional[numpy.ndarray]=None,
>                        y_hat_insample:Optional[numpy.ndarray]=None,
>                        sigmah:Optional[numpy.ndarray]=None,
>                        level:Optional[list[int]]=None,
>                        intervals_method:Optional[str]=None,
>                        num_samples:Optional[int]=None,
>                        seed:Optional[int]=None,
>                        tags:Optional[dict[str,numpy.ndarray]]=None)
> ```

\*BottomUp Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: In-sample values of size (`base`, `insample_size`).<br/>
`y_hat_insample`: In-sample forecast values of size (`base`,
`insample_size`).<br/> `sigmah`: Estimated standard deviation of the
conditional marginal distribution.<br/>  
`level`: float list 0-100, confidence levels for prediction
intervals.<br/> `intervals_method`: Sampler for prediction intervals, one
of `normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of
samples for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `**sampler_kwargs`: Coherent sampler instantiation
arguments.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the Bottom Up
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUp.sample

> ``` text
>  BottomUp.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L290"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUpSparse

> ``` text
>  BottomUpSparse ()
> ```

\*BottomUpSparse Reconciliation Class.

This is the implementation of a Bottom Up reconciliation using the
sparse matrix approach. It works much more efficient on datasets with
many time series. \[makoren: At least I hope so, I only checked up until
~20k time series, and there’s no real improvement, it would be great to
check for smth like 1M time series, where the dense S matrix really
stops fitting in memory\]

See the parent class for more details.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L189"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUpSparse.fit

> ``` text
>  BottomUpSparse.fit (S:numpy.ndarray, y_hat:numpy.ndarray,
>                      idx_bottom:numpy.ndarray,
>                      y_insample:Optional[numpy.ndarray]=None,
>                      y_hat_insample:Optional[numpy.ndarray]=None,
>                      sigmah:Optional[numpy.ndarray]=None,
>                      intervals_method:Optional[str]=None,
>                      num_samples:Optional[int]=None,
>                      seed:Optional[int]=None,
>                      tags:Optional[dict[str,numpy.ndarray]]=None)
> ```

\*Bottom Up Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: In-sample values of size (`base`, `horizon`).<br/>
`y_hat_insample`: In-sample forecast values of size (`base`,
`horizon`).<br/> `sigmah`: Estimated standard deviation of the
conditional marginal distribution.<br/>  
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `**sampler_kwargs`: Coherent sampler instantiation
arguments.<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUpSparse.predict

> ``` text
>  BottomUpSparse.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                          level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L237"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUpSparse.fit_predict

> ``` text
>  BottomUpSparse.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                              idx_bottom:numpy.ndarray,
>                              y_insample:Optional[numpy.ndarray]=None,
>                              y_hat_insample:Optional[numpy.ndarray]=None,
>                              sigmah:Optional[numpy.ndarray]=None,
>                              level:Optional[list[int]]=None,
>                              intervals_method:Optional[str]=None,
>                              num_samples:Optional[int]=None,
>                              seed:Optional[int]=None,
>                              tags:Optional[dict[str,numpy.ndarray]]=None)
> ```

\*BottomUp Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: In-sample values of size (`base`, `insample_size`).<br/>
`y_hat_insample`: In-sample forecast values of size (`base`,
`insample_size`).<br/> `sigmah`: Estimated standard deviation of the
conditional marginal distribution.<br/>  
`level`: float list 0-100, confidence levels for prediction
intervals.<br/> `intervals_method`: Sampler for prediction intervals, one
of `normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of
samples for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `**sampler_kwargs`: Coherent sampler instantiation
arguments.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the Bottom Up
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### BottomUpSparse.sample

> ``` text
>  BottomUpSparse.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

# 2. Top-Down

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L360"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDown

> ``` text
>  TopDown (method:str)
> ```

\*Top Down Reconciliation Class.

The Top Down hierarchical reconciliation method, distributes the total
aggregate predictions and decomposes it down the hierarchy using
proportions $\mathbf{p}_{\mathrm{[b]}}$ that can be actual historical
values or estimated.

$$\mathbf{P}=[\mathbf{p}_{\mathrm{[b]}}\;|\;\mathbf{0}_{\mathrm{[b][a,b\;-1]}}]$$
**Parameters:**<br/> `method`: One of `forecast_proportions`,
`average_proportions` and `proportion_averages`.<br/>

**References:**<br/> - [CW. Gross (1990). “Disaggregation methods to
expedite product line forecasting”. Journal of Forecasting, 9 , 233–254.
doi:10.1002/for.3980090304](https://onlinelibrary.wiley.com/doi/abs/10.1002/for.3980090304).<br/> -
[G. Fliedner (1999). “An investigation of aggregate variable time series
forecast strategies with specific subaggregate time series statistical
correlation”. Computers and Operations Research, 26 , 1133–1149.
doi:10.1016/S0305-0548(99)00017-9](https://doi.org/10.1016/S0305-0548(99)00017-9).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L435"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDown.fit

> ``` text
>  TopDown.fit (S, y_hat, y_insample:numpy.ndarray,
>               y_hat_insample:Optional[numpy.ndarray]=None,
>               sigmah:Optional[numpy.ndarray]=None,
>               intervals_method:Optional[str]=None,
>               num_samples:Optional[int]=None, seed:Optional[int]=None,
>               tags:Optional[dict[str,numpy.ndarray]]=None,
>               idx_bottom:Optional[numpy.ndarray]=None)
> ```

\*TopDown Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `y_insample`:
Insample values of size (`base`, `insample_size`). Optional for
`forecast_proportions` method.<br/> `y_hat_insample`: Insample forecast
values of size (`base`, `insample_size`). Optional for
`forecast_proportions` method.<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/>
`interval_method`: Sampler for prediction intervals, one of `normality`,
`bootstrap`, `permbu`.<br/> `num_samples`: Number of samples for
probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/> `idx_bottom`: Indices corresponding to the bottom level of
`S`, size (`bottom`).<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDown.predict

> ``` text
>  TopDown.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                   level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L485"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDown.fit_predict

> ``` text
>  TopDown.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                       tags:dict[str,numpy.ndarray],
>                       idx_bottom:numpy.ndarray=None,
>                       y_insample:Optional[numpy.ndarray]=None,
>                       y_hat_insample:Optional[numpy.ndarray]=None,
>                       sigmah:Optional[numpy.ndarray]=None,
>                       level:Optional[list[int]]=None,
>                       intervals_method:Optional[str]=None,
>                       num_samples:Optional[int]=None,
>                       seed:Optional[int]=None)
> ```

\*Top Down Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `tags`: Each
key is a level and each value its `S` indices.<br/> `idx_bottom`: Indices
corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: Insample values of size (`base`, `insample_size`).
Optional for `forecast_proportions` method.<br/> `y_hat_insample`:
Insample forecast values of size (`base`, `insample_size`). Optional for
`forecast_proportions` method.<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the Top Down
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDown.sample

> ``` text
>  TopDown.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L558"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDownSparse

> ``` text
>  TopDownSparse (method:str)
> ```

\*TopDownSparse Reconciliation Class.

This is an implementation of top-down reconciliation using the sparse
matrix approach. It works much more efficiently on data sets with many
time series.

See the parent class for more details.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L435"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDownSparse.fit

> ``` text
>  TopDownSparse.fit (S, y_hat, y_insample:numpy.ndarray,
>                     y_hat_insample:Optional[numpy.ndarray]=None,
>                     sigmah:Optional[numpy.ndarray]=None,
>                     intervals_method:Optional[str]=None,
>                     num_samples:Optional[int]=None,
>                     seed:Optional[int]=None,
>                     tags:Optional[dict[str,numpy.ndarray]]=None,
>                     idx_bottom:Optional[numpy.ndarray]=None)
> ```

\*TopDown Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `y_insample`:
Insample values of size (`base`, `insample_size`). Optional for
`forecast_proportions` method.<br/> `y_hat_insample`: Insample forecast
values of size (`base`, `insample_size`). Optional for
`forecast_proportions` method.<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/>
`interval_method`: Sampler for prediction intervals, one of `normality`,
`bootstrap`, `permbu`.<br/> `num_samples`: Number of samples for
probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/> `idx_bottom`: Indices corresponding to the bottom level of
`S`, size (`bottom`).<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDownSparse.predict

> ``` text
>  TopDownSparse.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                         level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L624"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDownSparse.fit_predict

> ``` text
>  TopDownSparse.fit_predict (S:scipy.sparse._csr.csr_matrix,
>                             y_hat:numpy.ndarray,
>                             tags:dict[str,numpy.ndarray],
>                             idx_bottom:numpy.ndarray=None,
>                             y_insample:Optional[numpy.ndarray]=None,
>                             y_hat_insample:Optional[numpy.ndarray]=None,
>                             sigmah:Optional[numpy.ndarray]=None,
>                             level:Optional[list[int]]=None,
>                             intervals_method:Optional[str]=None,
>                             num_samples:Optional[int]=None,
>                             seed:Optional[int]=None)
> ```

\*Top Down Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `tags`: Each
key is a level and each value its `S` indices.<br/> `idx_bottom`: Indices
corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: Insample values of size (`base`, `insample_size`).
Optional for `forecast_proportions` method.<br/> `y_hat_insample`:
Insample forecast values of size (`base`, `insample_size`). Optional for
`forecast_proportions` method.<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the Top Down
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TopDownSparse.sample

> ``` text
>  TopDownSparse.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

```python
cls_top_down(
                S=S, y_hat=S @ y_hat_bottom, y_insample=S @ y_bottom, tags=tags
            )["mean"]
```


```python
#\ hide
cls_top_down = TopDownSparse(method="average_proportions")
test_fail(
    cls_top_down,
    contains="Top-down reconciliation requires strictly hierarchical structures.",
    args=(sparse.csr_matrix(S_non_hier), None, tags_non_hier),
)
```

# 3. Middle-Out

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L699"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOut

> ``` text
>  MiddleOut (middle_level:str, top_down_method:str)
> ```

\*Middle Out Reconciliation Class.

This method is only available for **strictly hierarchical structures**.
It anchors the base predictions in a middle level. The levels above the
base predictions use the Bottom-Up approach, while the levels below use
a Top-Down.

**Parameters:**<br/> `middle_level`: Middle level.<br/> `top_down_method`:
One of `forecast_proportions`, `average_proportions` and
`proportion_averages`.<br/>

**References:**<br/> - [Hyndman, R.J., & Athanasopoulos, G. (2021).
“Forecasting: principles and practice, 3rd edition: Chapter 11:
Forecasting hierarchical and grouped series.”. OTexts: Melbourne,
Australia. OTexts.com/fpp3 Accessed on July
2022.](https://otexts.com/fpp3/hierarchical.html)\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L728"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOut.fit

> ``` text
>  MiddleOut.fit (**kwargs)
> ```

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L731"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOut.predict

> ``` text
>  MiddleOut.predict (**kwargs)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L734"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOut.fit_predict

> ``` text
>  MiddleOut.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                         tags:dict[str,numpy.ndarray],
>                         y_insample:Optional[numpy.ndarray]=None,
>                         level:Optional[list[int]]=None,
>                         intervals_method:Optional[str]=None)
> ```

\*Middle Out Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `tags`: Each
key is a level and each value its `S` indices.<br/> `y_insample`:
Insample values of size (`base`, `insample_size`). Only used for
`forecast_proportions`<br/> `level`: Not supported. <br/>
`intervals_method`: Not supported.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the Middle Out
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOut.sample

> ``` text
>  MiddleOut.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L828"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOutSparse

> ``` text
>  MiddleOutSparse (middle_level:str, top_down_method:str)
> ```

\*MiddleOutSparse Reconciliation Class.

This is an implementation of middle-out reconciliation using the sparse
matrix approach. It works much more efficiently on data sets with many
time series.

See the parent class for more details.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L728"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOutSparse.fit

> ``` text
>  MiddleOutSparse.fit (**kwargs)
> ```

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L731"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOutSparse.predict

> ``` text
>  MiddleOutSparse.predict (**kwargs)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L843"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOutSparse.fit_predict

> ``` text
>  MiddleOutSparse.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                               tags:dict[str,numpy.ndarray],
>                               y_insample:Optional[numpy.ndarray]=None,
>                               level:Optional[list[int]]=None,
>                               intervals_method:Optional[str]=None)
> ```

\*Middle Out Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `tags`: Each
key is a level and each value its `S` indices.<br/> `y_insample`:
Insample values of size (`base`, `insample_size`). Only used for
`forecast_proportions`<br/> `level`: Not supported. <br/>
`intervals_method`: Not supported.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the Middle Out
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MiddleOutSparse.sample

> ``` text
>  MiddleOutSparse.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

# 4. Min-Trace

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L930"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTrace

> ``` text
>  MinTrace (method:str, nonnegative:bool=False,
>            mint_shr_ridge:Optional[float]=2e-08, num_threads:int=1)
> ```

\*MinTrace Reconciliation Class.

This reconciliation algorithm proposed by Wickramasuriya et al. depends
on a generalized least squares estimator and an estimator of the
covariance matrix of the coherency errors $\mathbf{W}_{h}$. The Min
Trace algorithm minimizes the squared errors for the coherent forecasts
under an unbiasedness assumption; the solution has a closed form.<br/>

$$

\mathbf{P}_{\text{MinT}}=\left(\mathbf{S}^{\intercal}\mathbf{W}_{h}\mathbf{S}\right)^{-1}
\mathbf{S}^{\intercal}\mathbf{W}^{-1}_{h}

$$

**Parameters:**<br/> `method`: str, one of `ols`, `wls_struct`,
`wls_var`, `mint_shrink`, `mint_cov`.<br/> `nonnegative`: bool,
reconciled forecasts should be nonnegative?<br/> `mint_shr_ridge`:
float=2e-8, ridge numeric protection to MinTrace-shr covariance
estimator.<br/> `num_threads`: int=1, number of threads to use for
solving the optimization problems (when nonnegative=True).

**References:**<br/> - [Wickramasuriya, S. L., Athanasopoulos, G., &
Hyndman, R. J. (2019). “Optimal forecast reconciliation for hierarchical
and grouped time series through trace minimization”. Journal of the
American Statistical Association, 114 , 804–819.
doi:10.1080/01621459.2018.1448825.](https://robjhyndman.com/publications/mint/). -
[Wickramasuriya, S.L., Turlach, B.A. & Hyndman, R.J. (2020). “Optimal
non-negative forecast reconciliation”. Stat Comput 30, 1167–1182,
https://doi.org/10.1007/s11222-020-09930-0](https://robjhyndman.com/publications/nnmint/).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1077"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTrace.fit

> ``` text
>  MinTrace.fit (S, y_hat, y_insample:Optional[numpy.ndarray]=None,
>                y_hat_insample:Optional[numpy.ndarray]=None,
>                sigmah:Optional[numpy.ndarray]=None,
>                intervals_method:Optional[str]=None,
>                num_samples:Optional[int]=None, seed:Optional[int]=None,
>                tags:Optional[dict[str,numpy.ndarray]]=None,
>                idx_bottom:Optional[numpy.ndarray]=None)
> ```

\*MinTrace Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `y_insample`:
Insample values of size (`base`, `insample_size`). Only used with
“wls_var”, “mint_cov”, “mint_shrink”.<br/> `y_hat_insample`: Insample
forecast values of size (`base`, `insample_size`). Only used with
“wls_var”, “mint_cov”, “mint_shrink”<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/>
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/> `idx_bottom`: Indices corresponding to the bottom level of
`S`, size (`bottom`).<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTrace.predict

> ``` text
>  MinTrace.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                    level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1183"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTrace.fit_predict

> ``` text
>  MinTrace.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                        idx_bottom:numpy.ndarray=None,
>                        y_insample:Optional[numpy.ndarray]=None,
>                        y_hat_insample:Optional[numpy.ndarray]=None,
>                        sigmah:Optional[numpy.ndarray]=None,
>                        level:Optional[list[int]]=None,
>                        intervals_method:Optional[str]=None,
>                        num_samples:Optional[int]=None,
>                        seed:Optional[int]=None,
>                        tags:Optional[dict[str,numpy.ndarray]]=None)
> ```

\*MinTrace Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: Insample values of size (`base`, `insample_size`). Only
used by `wls_var`, `mint_cov`, `mint_shrink`<br/> `y_hat_insample`:
Insample fitted values of size (`base`, `insample_size`). Only used by
`wls_var`, `mint_cov`, `mint_shrink`<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the MinTrace
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTrace.sample

> ``` text
>  MinTrace.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1246"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTraceSparse

> ``` text
>  MinTraceSparse (method:str, nonnegative:bool=False, num_threads:int=1,
>                  qp:bool=True)
> ```

\*MinTraceSparse Reconciliation Class.

This is the implementation of OLS and WLS estimators using sparse
matrices. It is not guaranteed to give identical results to the
non-sparse version, but works much more efficiently on data sets with
many time series.<br/>

See the parent class for more details.<br/>

**Parameters:**<br/> `method`: str, one of `ols`, `wls_struct`, or
`wls_var`.<br/> `nonnegative`: bool, return non-negative reconciled
forecasts.<br/> `num_threads`: int, number of threads to execute
non-negative quadratic programming calls.<br/> `qp`: bool, implement
non-negativity constraint with a quadratic programming approach. Setting
this to True generally gives better results, but at the expense of
higher cost to compute. <br/>\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1367"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTraceSparse.fit

> ``` text
>  MinTraceSparse.fit (S:scipy.sparse._csr.csr_matrix, y_hat:numpy.ndarray,
>                      y_insample:Optional[numpy.ndarray]=None,
>                      y_hat_insample:Optional[numpy.ndarray]=None,
>                      sigmah:Optional[numpy.ndarray]=None,
>                      intervals_method:Optional[str]=None,
>                      num_samples:Optional[int]=None,
>                      seed:Optional[int]=None,
>                      tags:Optional[dict[str,numpy.ndarray]]=None,
>                      idx_bottom:Optional[numpy.ndarray]=None)
> ```

\*MinTraceSparse Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `y_insample`:
Insample values of size (`base`, `insample_size`). Only used with
“wls_var”.<br/> `y_hat_insample`: Insample forecast values of size
(`base`, `insample_size`). Only used with “wls_var”<br/> `sigmah`:
Estimated standard deviation of the conditional marginal
distribution.<br/> `intervals_method`: Sampler for prediction intervals,
one of `normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of
samples for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/> `idx_bottom`: Indices corresponding to the bottom level of
`S`, size (`bottom`).<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTraceSparse.predict

> ``` text
>  MinTraceSparse.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                          level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1183"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTraceSparse.fit_predict

> ``` text
>  MinTraceSparse.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                              idx_bottom:numpy.ndarray=None,
>                              y_insample:Optional[numpy.ndarray]=None,
>                              y_hat_insample:Optional[numpy.ndarray]=None,
>                              sigmah:Optional[numpy.ndarray]=None,
>                              level:Optional[list[int]]=None,
>                              intervals_method:Optional[str]=None,
>                              num_samples:Optional[int]=None,
>                              seed:Optional[int]=None,
>                              tags:Optional[dict[str,numpy.ndarray]]=None)
> ```

\*MinTrace Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: Insample values of size (`base`, `insample_size`). Only
used by `wls_var`, `mint_cov`, `mint_shrink`<br/> `y_hat_insample`:
Insample fitted values of size (`base`, `insample_size`). Only used by
`wls_var`, `mint_cov`, `mint_shrink`<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the MinTrace
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MinTraceSparse.sample

> ``` text
>  MinTraceSparse.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

# 5. Optimal Combination

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1573"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### OptimalCombination

> ``` text
>  OptimalCombination (method:str, nonnegative:bool=False,
>                      num_threads:int=1)
> ```

\*Optimal Combination Reconciliation Class.

This reconciliation algorithm was proposed by Hyndman et al. 2011, the
method uses generalized least squares estimator using the coherency
errors covariance matrix. Consider the covariance of the base forecast
$\textrm{Var}(\epsilon_{h}) = \Sigma_{h}$, the $\mathbf{P}$ matrix of
this method is defined by:
$$ \mathbf{P} = \left(\mathbf{S}^{\intercal}\Sigma_{h}^{\dagger}\mathbf{S}\right)^{-1}\mathbf{S}^{\intercal}\Sigma^{\dagger}_{h}$$
where $\Sigma_{h}^{\dagger}$ denotes the variance pseudo-inverse. The
method was later proven equivalent to
[`MinTrace`](https://Nixtla.github.io/hierarchicalforecast/src/methods.html#mintrace)
variants.

**Parameters:**<br/> `method`: str, allowed optimal combination methods:
‘ols’, ‘wls_struct’.<br/> `nonnegative`: bool, reconciled forecasts
should be nonnegative?<br/>

**References:**<br/> - [Rob J. Hyndman, Roman A. Ahmed, George
Athanasopoulos, Han Lin Shang (2010). “Optimal Combination Forecasts for
Hierarchical Time
Series”.](https://robjhyndman.com/papers/Hierarchical6.pdf).<br/> -
[Shanika L. Wickramasuriya, George Athanasopoulos and Rob J. Hyndman
(2010). “Optimal Combination Forecasts for Hierarchical Time
Series”.](https://robjhyndman.com/papers/MinT.pdf). - [Wickramasuriya,
S.L., Turlach, B.A. & Hyndman, R.J. (2020). “Optimal non-negative
forecast reconciliation”. Stat Comput 30, 1167–1182,
https://doi.org/10.1007/s11222-020-09930-0](https://robjhyndman.com/publications/nnmint/).\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1077"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### OptimalCombination.fit

> ``` text
>  OptimalCombination.fit (S, y_hat,
>                          y_insample:Optional[numpy.ndarray]=None,
>                          y_hat_insample:Optional[numpy.ndarray]=None,
>                          sigmah:Optional[numpy.ndarray]=None,
>                          intervals_method:Optional[str]=None,
>                          num_samples:Optional[int]=None,
>                          seed:Optional[int]=None,
>                          tags:Optional[dict[str,numpy.ndarray]]=None,
>                          idx_bottom:Optional[numpy.ndarray]=None)
> ```

\*MinTrace Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `y_insample`:
Insample values of size (`base`, `insample_size`). Only used with
“wls_var”, “mint_cov”, “mint_shrink”.<br/> `y_hat_insample`: Insample
forecast values of size (`base`, `insample_size`). Only used with
“wls_var”, “mint_cov”, “mint_shrink”<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/>
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/> `idx_bottom`: Indices corresponding to the bottom level of
`S`, size (`bottom`).<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### OptimalCombination.predict

> ``` text
>  OptimalCombination.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                              level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1183"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### OptimalCombination.fit_predict

> ``` text
>  OptimalCombination.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                                  idx_bottom:numpy.ndarray=None,
>                                  y_insample:Optional[numpy.ndarray]=None, 
>                                  y_hat_insample:Optional[numpy.ndarray]=No
>                                  ne, sigmah:Optional[numpy.ndarray]=None,
>                                  level:Optional[list[int]]=None,
>                                  intervals_method:Optional[str]=None,
>                                  num_samples:Optional[int]=None,
>                                  seed:Optional[int]=None, tags:Optional[di
>                                  ct[str,numpy.ndarray]]=None)
> ```

\*MinTrace Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: Insample values of size (`base`, `insample_size`). Only
used by `wls_var`, `mint_cov`, `mint_shrink`<br/> `y_hat_insample`:
Insample fitted values of size (`base`, `insample_size`). Only used by
`wls_var`, `mint_cov`, `mint_shrink`<br/> `sigmah`: Estimated standard
deviation of the conditional marginal distribution.<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>
`intervals_method`: Sampler for prediction intervals, one of
`normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of samples
for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the MinTrace
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### OptimalCombination.sample

> ``` text
>  OptimalCombination.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

# 6. Emp. Risk Minimization

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1609"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### ERM

> ``` text
>  ERM (method:str, lambda_reg:float=0.01)
> ```

\*Optimal Combination Reconciliation Class.

The Empirical Risk Minimization reconciliation strategy relaxes the
unbiasedness assumptions from previous reconciliation methods like MinT
and optimizes square errors between the reconciled predictions and the
validation data to obtain an optimal reconciliation matrix P.

The exact solution for $\mathbf{P}$ (`method='closed'`) follows the
expression:
$$\mathbf{P}^{*} = \left(\mathbf{S}^{\intercal}\mathbf{S}\right)^{-1}\mathbf{Y}^{\intercal}\hat{\mathbf{Y}}\left(\hat{\mathbf{Y}}\hat{\mathbf{Y}}\right)^{-1}$$

The alternative Lasso regularized $\mathbf{P}$ solution
(`method='reg_bu'`) is useful when the observations of validation data
is limited or the exact solution has low numerical stability.
$$\mathbf{P}^{*} = \text{argmin}_{\mathbf{P}} ||\mathbf{Y}-\mathbf{S} \mathbf{P} \hat{Y} ||^{2}_{2} + \lambda ||\mathbf{P}-\mathbf{P}_{\text{BU}}||_{1}$$

**Parameters:**<br/> `method`: str, one of `closed`, `reg` and
`reg_bu`.<br/> `lambda_reg`: float, l1 regularizer for `reg` and
`reg_bu`.<br/>

**References:**<br/> - [Ben Taieb, S., & Koo, B. (2019). Regularized
regression for hierarchical forecasting without unbiasedness conditions.
In Proceedings of the 25th ACM SIGKDD International Conference on
Knowledge Discovery & Data Mining KDD ’19 (p. 1337-1347). New York, NY,
USA: Association for Computing
Machinery.](https://doi.org/10.1145/3292500.3330976).<br/>\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1699"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### ERM.fit

> ``` text
>  ERM.fit (S, y_hat, y_insample, y_hat_insample,
>           sigmah:Optional[numpy.ndarray]=None,
>           intervals_method:Optional[str]=None,
>           num_samples:Optional[int]=None, seed:Optional[int]=None,
>           tags:Optional[dict[str,numpy.ndarray]]=None,
>           idx_bottom:Optional[numpy.ndarray]=None)
> ```

\*ERM Fit Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `y_insample`:
Train values of size (`base`, `insample_size`).<br/> `y_hat_insample`:
Insample train predictions of size (`base`, `insample_size`).<br/>
`sigmah`: Estimated standard deviation of the conditional marginal
distribution.<br/> `intervals_method`: Sampler for prediction intervals,
one of `normality`, `bootstrap`, `permbu`.<br/> `num_samples`: Number of
samples for probabilistic coherent distribution.<br/> `seed`: Seed for
reproducibility.<br/> `tags`: Each key is a level and each value its `S`
indices.<br/> `idx_bottom`: Indices corresponding to the bottom level of
`S`, size (`bottom`).<br/>

**Returns:**<br/> `self`: object, fitted reconciler.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L106"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### ERM.predict

> ``` text
>  ERM.predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>               level:Optional[list[int]]=None)
> ```

\*Predict using reconciler.

Predict using fitted mean and probabilistic reconcilers.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `level`: float
list 0-100, confidence levels for prediction intervals.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated predictions.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L1752"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### ERM.fit_predict

> ``` text
>  ERM.fit_predict (S:numpy.ndarray, y_hat:numpy.ndarray,
>                   idx_bottom:numpy.ndarray=None,
>                   y_insample:Optional[numpy.ndarray]=None,
>                   y_hat_insample:Optional[numpy.ndarray]=None,
>                   sigmah:Optional[numpy.ndarray]=None,
>                   level:Optional[list[int]]=None,
>                   intervals_method:Optional[str]=None,
>                   num_samples:Optional[int]=None, seed:Optional[int]=None,
>                   tags:Optional[dict[str,numpy.ndarray]]=None)
> ```

\*ERM Reconciliation Method.

**Parameters:**<br/> `S`: Summing matrix of size (`base`, `bottom`).<br/>
`y_hat`: Forecast values of size (`base`, `horizon`).<br/> `idx_bottom`:
Indices corresponding to the bottom level of `S`, size (`bottom`).<br/>
`y_insample`: Train values of size (`base`, `insample_size`).<br/>
`y_hat_insample`: Insample train predictions of size (`base`,
`insample_size`).<br/> `sigmah`: Estimated standard deviation of the
conditional marginal distribution.<br/> `level`: float list 0-100,
confidence levels for prediction intervals.<br/> `intervals_method`:
Sampler for prediction intervals, one of `normality`, `bootstrap`,
`permbu`.<br/> `num_samples`: Number of samples for probabilistic
coherent distribution.<br/> `seed`: Seed for reproducibility.<br/> `tags`:
Each key is a level and each value its `S` indices.<br/>

**Returns:**<br/> `y_tilde`: Reconciliated y_hat using the ERM
approach.\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/hierarchicalforecast/blob/main/hierarchicalforecast/methods.py#L128"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### ERM.sample

> ``` text
>  ERM.sample (num_samples:int)
> ```

\*Sample probabilistic coherent distribution.

Generates n samples from a probabilistic coherent distribution. The
method uses fitted mean and probabilistic reconcilers, defined by the
`intervals_method` selected during the reconciler’s instantiation.
Currently available: `normality`, `bootstrap`, `permbu`.

**Parameters:**<br/> `num_samples`: int, number of samples generated from
coherent distribution.<br/>

**Returns:**<br/> `samples`: Coherent samples of size (`num_series`,
`horizon`, `num_samples`).\*

```python
S @ y_hat_bottom_insample
```

# References

### General Reconciliation

-   [Orcutt, G.H., Watts, H.W., & Edwards, J.B.(1968). Data aggregation
    and information loss. The American Economic Review, 58 ,
    773(787).](http://www.jstor.org/stable/1815532)<br/>
-   [Disaggregation methods to expedite product line forecasting.
    Journal of Forecasting, 9 , 233–254.
    doi:10.1002/for.3980090304](https://onlinelibrary.wiley.com/doi/abs/10.1002/for.3980090304).<br/>
-   [An investigation of aggregate variable time series forecast
    strategies with specific subaggregate time series statistical
    correlation. Computers and Operations Research, 26 , 1133–1149.
    doi:10.1016/S0305-0548(99)00017-9.](https://doi.org/10.1016/S0305-0548(99)00017-9)<br/>
-   [Hyndman, R.J., & Athanasopoulos, G. (2021). “Forecasting:
    principles and practice, 3rd edition: Chapter 11: Forecasting
    hierarchical and grouped series.”. OTexts: Melbourne, Australia.
    OTexts.com/fpp3 Accessed on July
    2022.](https://otexts.com/fpp3/hierarchical.html)

### Optimal Reconciliation

-   [Rob J. Hyndman, Roman A. Ahmed, George Athanasopoulos, Han Lin
    Shang. “Optimal Combination Forecasts for Hierarchical Time Series”
    (2010).](https://robjhyndman.com/papers/Hierarchical6.pdf)<br/>
-   [Shanika L. Wickramasuriya, George Athanasopoulos and Rob J.
    Hyndman. “Optimal Combination Forecasts for Hierarchical Time
    Series” (2010).](https://robjhyndman.com/papers/MinT.pdf)<br/>
-   [Ben Taieb, S., & Koo, B. (2019). Regularized regression for
    hierarchical forecasting without unbiasedness conditions. In
    Proceedings of the 25th ACM SIGKDD International Conference on
    Knowledge Discovery & Data Mining KDD ’19 (p. 1337-1347). New York,
    NY, USA: Association for Computing
    Machinery.](https://doi.org/10.1145/3292500.3330976)<br/>

### Hierarchical Probabilistic Coherent Predictions

-   [Puwasala Gamakumara Ph. D. dissertation. Monash University,
    Econometrics and Business Statistics. “Probabilistic Forecast
    Reconciliation”.](https://bridges.monash.edu/articles/thesis/Probabilistic_Forecast_Reconciliation_Theory_and_Applications/11869533)<br/>
-   [Taieb, Souhaib Ben and Taylor, James W and Hyndman, Rob J. (2017).
    Coherent probabilistic forecasts for hierarchical time series.
    International conference on machine learning
    ICML.](https://proceedings.mlr.press/v70/taieb17a.html)<br/>


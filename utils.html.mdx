---
output-file: utils.html
title: Aggregation/Visualization Utils
---


The `HierarchicalForecast` package contains utility functions to wrangle
and visualize hierarchical series datasets. The
[`aggregate`](https://Nixtla.github.io/hierarchicalforecast/src/utils.html#aggregate)
function of the module allows you to create a hierarchy from categorical
variables representing the structure levels, returning also the
aggregation contraints matrix $\mathbf{S}$.

In addition, `HierarchicalForecast` ensures compatibility of its
reconciliation methods with other popular machine-learning libraries via
its external forecast adapters that transform output base forecasts from
external libraries into a compatible data frame format.

## Aggregate Function

### `aggregate`

```python
aggregate(df, spec, exog_vars=None, sparse_s=False, id_col='unique_id', time_col='ds', id_time_col=None, target_cols=('y',))
```

Utils Aggregation Function.

Aggregates bottom level series contained in the DataFrame `df` according
to levels defined in the `spec` list.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`df` | <code>[Frame](#narwhals.typing.Frame)</code> | Dataframe with columns `[time_col, *target_cols]`, columns to aggregate and optionally exog_vars. | *required*
`spec` | <code>[list](#list)\[[list](#list)\[[str](#str)\]\]</code> | list of levels. Each element of the list should contain a list of columns of `df` to aggregate. | *required*
`exog_vars` | <code>[Optional](#typing.Optional)\[[dict](#dict)\[[str](#str), [Union](#typing.Union)\[[str](#str), [list](#list)\[[str](#str)\]\]\]\]</code> | dictionary of string keys & values that can either be a list of strings or a single string
keys correspond to column names and the values represent the aggregation(s) that will be applied to each column. Accepted values are those from Pandas or Polars aggregation Functions, check the respective docs for guidance. Default is None. | <code>None</code>
`sparse_s` | <code>[bool](#bool)</code> | Return `S_df` as a sparse Pandas dataframe. Default is False. | <code>False</code>
`id_col` | <code>[str](#str)</code> | Column that will identify each serie after aggregation. Default is "unique_id". | <code>'unique_id'</code>
`time_col` | <code>[str](#str)</code> | Column that identifies each timestep, its values can be timestamps or integers. Default is "ds". | <code>'ds'</code>
`id_time_col` | <code>[Optional](#typing.Optional)\[[str](#str)\]</code> | Column that will identify each timestep after temporal aggregation. If provided, aggregate will operate temporally. Default is None. | <code>None</code>
`target_cols` | <code>[Sequence](#collections.abc.Sequence)\[[str](#str)\]</code> | list of columns that contains the targets to aggregate. Default is ("y",). | <code>('y',)</code>

**Returns:**

Type | Description
---- | -----------
<code>[tuple](#tuple)\[[FrameT](#narwhals.typing.FrameT), [FrameT](#narwhals.typing.FrameT), [dict](#dict)\]</code> | tuple\[FrameT, FrameT, dict\]: Y_df, S_df, tags
Y_df: Hierarchically structured series.
S_df: Summing dataframe.
tags: Aggregation indices.

### `aggregate_temporal`

```python
aggregate_temporal(df, spec, exog_vars=None, sparse_s=False, id_col='unique_id', time_col='ds', id_time_col='temporal_id', target_cols=('y',), aggregation_type='local')
```

Utils Aggregation Function for Temporal aggregations.

Aggregates bottom level timesteps contained in the DataFrame `df` according
to temporal levels defined in the `spec` list.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`df` | <code>[Frame](#narwhals.typing.Frame)</code> | Dataframe with columns `[time_col, target_cols]` and columns to aggregate. | *required*
`spec` | <code>[dict](#dict)\[[str](#str), [int](#int)\]</code> | Dictionary of temporal levels. Each key should be a string with the value representing the number of bottom-level timesteps contained in the aggregation. | *required*
`exog_vars` | <code>[Optional](#typing.Optional)\[[dict](#dict)\[[str](#str), [Union](#typing.Union)\[[str](#str), [list](#list)\[[str](#str)\]\]\]\]</code> | dictionary of string keys & values that can either be a list of strings or a single string
keys correspond to column names and the values represent the aggregation(s) that will be applied to each column. Accepted values are those from Pandas or Polars aggregation Functions, check the respective docs for guidance. Default is None. | <code>None</code>
`sparse_s` | <code>[bool](#bool)</code> | Return `S_df` as a sparse Pandas dataframe. Default is False. | <code>False</code>
`id_col` | <code>[str](#str)</code> | Column that will identify each serie after aggregation. Default is 'unique_id'. | <code>'unique_id'</code>
`time_col` | <code>[str](#str)</code> | Column that identifies each timestep, its values can be timestamps or integers. Default is 'ds'. | <code>'ds'</code>
`id_time_col` | <code>[str](#str)</code> | Column that will identify each timestep after aggregation. Default is 'temporal_id'. | <code>'temporal_id'</code>
`target_cols` | <code>[Sequence](#collections.abc.Sequence)\[[str](#str)\]</code> | List of columns that contain the targets to aggregate. Default is ('y',). | <code>('y',)</code>
`aggregation_type` | <code>[str](#str)</code> | If 'local' the aggregation will be performed on the timestamps of each timeseries independently. If 'global' the aggregation will be performed on the unique timestamps of all timeseries. Default is 'local'. | <code>'local'</code>

**Returns:**

Type | Description
---- | -----------
<code>[tuple](#tuple)\[[FrameT](#narwhals.typing.FrameT), [FrameT](#narwhals.typing.FrameT), [dict](#dict)\]</code> | tuple\[FrameT, FrameT, dict\]: Y_df, S_df, tags
Y_df: Temporally hierarchically structured series.
S_df: Temporal summing dataframe.
tags: Temporal aggregation indices.

### `make_future_dataframe`

```python
make_future_dataframe(df, freq, h, id_col='unique_id', time_col='ds')
```

Create future dataframe for forecasting.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`df` | <code>[Frame](#narwhals.typing.Frame)</code> | Dataframe with ids, times and values for the exogenous regressors. | *required*
`freq` | <code>[Union](#typing.Union)\[[str](#str), [int](#int)\]</code> | Frequency of the data. Must be a valid pandas or polars offset alias, or an integer. | *required*
`h` | <code>[int](#int)</code> | Forecast horizon. | *required*
`id_col` | <code>[str](#str)</code> | Column that identifies each serie. Default is 'unique_id'. | <code>'unique_id'</code>
`time_col` | <code>[str](#str)</code> | Column that identifies each timestep, its values can be timestamps or integers. Default is 'ds'. | <code>'ds'</code>

**Returns:**

Name | Type | Description
---- | ---- | -----------
`FrameT` | <code>[FrameT](#narwhals.typing.FrameT)</code> | DataFrame with future values.

### `get_cross_temporal_tags`

```python
get_cross_temporal_tags(df, tags_cs, tags_te, sep='//', id_col='unique_id', id_time_col='temporal_id', cross_temporal_id_col='cross_temporal_id')
```

Get cross-temporal tags.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`df` | <code>[Frame](#narwhals.typing.Frame)</code> | DataFrame with temporal ids. | *required*
`tags_cs` | <code>[dict](#dict)\[[str](#str), [ndarray](#numpy.ndarray)\]</code> | Tags for the cross-sectional hierarchies. | *required*
`tags_te` | <code>[dict](#dict)\[[str](#str), [ndarray](#numpy.ndarray)\]</code> | Tags for the temporal hierarchies. | *required*
`sep` | <code>[str](#str)</code> | Separator for the cross-temporal tags. Default is "//". | <code>'//'</code>
`id_col` | <code>[str](#str)</code> | Column that identifies each serie. Default is 'unique_id'. | <code>'unique_id'</code>
`id_time_col` | <code>[str](#str)</code> | Column that identifies each (aggregated) timestep. Default is 'temporal_id'. | <code>'temporal_id'</code>
`cross_temporal_id_col` | <code>[str](#str)</code> | Column that will identify each cross-temporal aggregation. Default is 'cross_temporal_id'. | <code>'cross_temporal_id'</code>

**Returns:**

Type | Description
---- | -----------
<code>[tuple](#tuple)\[[FrameT](#narwhals.typing.FrameT), [dict](#dict)\[[str](#str), [ndarray](#numpy.ndarray)\]\]</code> | tuple\[FrameT, dict[str, np.ndarray]\]: df, tags_ct
df: DataFrame with cross-temporal ids.
tags_ct: Tags for the cross-temporal hierarchies.

## Hierarchical Visualization

### `HierarchicalPlot`

```python
HierarchicalPlot(S, tags, S_id_col='unique_id')
```

Hierarchical Plot

This class contains a collection of matplotlib visualization methods, suited for small
to medium sized hierarchical series.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`S` | <code>[Frame](#narwhals.typing.Frame)</code> | DataFrame with summing matrix of size `(base, bottom)`, see [aggregate function](./utils#function-aggregate). | *required*
`tags` | <code>[dict](#dict)\[[str](#str), [ndarray](#numpy.ndarray)\]</code> | hierarchical aggregation indexes, where
each key is a level and its value contains tags associated to that level. | *required*
`S_id_col` | <code>[str](#str)</code> | column that identifies each aggregation. Default is 'unique_id'. | <code>'unique_id'</code>

#### `HierarchicalPlot.S`

```python
S = nw.from_native(S)
```

#### `HierarchicalPlot.S_cols_ex_id_col`

```python
S_cols_ex_id_col = S_cols_ex_id_col
```

#### `HierarchicalPlot.plot_hierarchical_predictions_gap`

```python
plot_hierarchical_predictions_gap(Y_df, models=None, xlabel=None, ylabel=None, id_col='unique_id', time_col='ds', target_col='y')
```

Hierarchically Predictions Gap plot

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`Y_df` | <code>[Frame](#narwhals.typing.Frame)</code> | hierarchically structured series ($\\mathbf{y}\_{[a,b]}$).
It contains columns ['unique_id', 'ds', 'y'] and models. | *required*
`models` | <code>[Optional](#typing.Optional)\[[list](#list)\[[str](#str)\]\]</code> | string identifying filtering model columns. Default is None. | <code>None</code>
`xlabel` | <code>[Optional](#typing.Optional)\[[str](#str)\]</code> | string for the plot's x axis label. Default is None. | <code>None</code>
`ylabel` | <code>[Optional](#typing.Optional)\[[str](#str)\]</code> | string for the plot's y axis label. Default is None. | <code>None</code>
`id_col` | <code>[str](#str)</code> | column that identifies each serie. Default is 'unique_id'. | <code>'unique_id'</code>
`time_col` | <code>[str](#str)</code> | column that identifies each timestep, its values can be timestamps or integers. Default is 'ds'. | <code>'ds'</code>
`target_col` | <code>[str](#str)</code> | column that contains the target. Default is 'y'. | <code>'y'</code>

**Returns:**

Type | Description
---- | -----------
| matplotlib.figure.Figure: figure object containing the plot of the aggregated predictions at different levels of the hierarchical structure.

#### `HierarchicalPlot.plot_hierarchically_linked_series`

```python
plot_hierarchically_linked_series(bottom_series, Y_df, models=None, level=None, id_col='unique_id', time_col='ds', target_col='y')
```

Hierarchically Linked Series plot

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`bottom_series` | <code>[str](#str)</code> | string identifying the `'unique_id'` bottom-level series to plot. | *required*
`Y_df` | <code>[Frame](#narwhals.typing.Frame)</code> | hierarchically structured series ($\\mathbf{y}\_{[a,b]}$).
It contains columns ['unique_id', 'ds', 'y'] and models. | *required*
`models` | <code>[Optional](#typing.Optional)\[[list](#list)\[[str](#str)\]\]</code> | string identifying filtering model columns. Default is None. | <code>None</code>
`level` | <code>[Optional](#typing.Optional)\[[list](#list)\[[int](#int)\]\]</code> | confidence levels for prediction intervals available in `Y_df`. Default is None. | <code>None</code>
`id_col` | <code>[str](#str)</code> | column that identifies each serie. Default is 'unique_id'. | <code>'unique_id'</code>
`time_col` | <code>[str](#str)</code> | column that identifies each timestep, its values can be timestamps or integers. Default is 'ds'. | <code>'ds'</code>
`target_col` | <code>[str](#str)</code> | column that contains the target. Default is 'y'. | <code>'y'</code>

**Returns:**

Type | Description
---- | -----------
| matplotlib.figure.Figure: figure object containing the plots of the hierarchilly linked series.

#### `HierarchicalPlot.plot_series`

```python
plot_series(series, Y_df, models=None, level=None, id_col='unique_id', time_col='ds', target_col='y')
```

Single Series plot

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`series` | <code>[str](#str)</code> | string identifying the `'unique_id'` any-level series to plot. | *required*
`Y_df` | <code>[Frame](#narwhals.typing.Frame)</code> | hierarchically structured series ($\\mathbf{y}\_{[a,b]}$).
It contains columns `['unique_id', 'ds', 'y']`, it may have `'models'`. | *required*
`models` | <code>[Optional](#typing.Optional)\[[list](#list)\[[str](#str)\]\]</code> | string identifying filtering model columns. Default is None. | <code>None</code>
`level` | <code>[Optional](#typing.Optional)\[[list](#list)\[[int](#int)\]\]</code> | confidence levels for prediction intervals available in `Y_df`. Default is None. | <code>None</code>
`id_col` | <code>[str](#str)</code> | column that identifies each serie. Default is 'unique_id'. | <code>'unique_id'</code>
`time_col` | <code>[str](#str)</code> | column that identifies each timestep, its values can be timestamps or integers. Default is 'ds'. | <code>'ds'</code>
`target_col` | <code>[str](#str)</code> | column that contains the target. Default is 'y'. | <code>'y'</code>

**Returns:**

Type | Description
---- | -----------
| matplotlib.figure.Figure: figure object containing the plot of the single series.

#### `HierarchicalPlot.plot_summing_matrix`

```python
plot_summing_matrix()
```

Summation Constraints plot

This method simply plots the hierarchical aggregation
constraints matrix $\\mathbf{S}$.

**Returns:**

Type | Description
---- | -----------
| matplotlib.figure.Figure: figure object containing the plot of the summing matrix.

#### `HierarchicalPlot.tags`

```python
tags = tags
```





```python
from statsforecast.core import StatsForecast
from statsforecast.models import AutoETS
from datasetsforecast.hierarchical import HierarchicalData

Y_df, S, tags = HierarchicalData.load('./data', 'Labour')
Y_df['ds'] = pd.to_datetime(Y_df['ds'])
S = S.reset_index(names="unique_id")

Y_test_df  = Y_df.groupby('unique_id').tail(24)
Y_train_df = Y_df.drop(Y_test_df.index)

fcst = StatsForecast(
    models=[AutoETS(season_length=12, model='AAZ')],
    freq='MS',
    n_jobs=-1
)
Y_hat_df = fcst.forecast(df=Y_train_df, h=24).reset_index()

# Plot prediction difference of different aggregation
# Levels Country, Country/Region, Country/Gender/Region ...
hplots = HierarchicalPlot(S=S, tags=tags)

hplots.plot_hierarchical_predictions_gap(
    Y_df=Y_hat_df, models='AutoETS',
    xlabel='Month', ylabel='Predictions',
)
```


```python
# polars
from statsforecast.core import StatsForecast
from statsforecast.models import AutoETS
from datasetsforecast.hierarchical import HierarchicalData

Y_df, S, tags = HierarchicalData.load('./data', 'Labour')
Y_df['ds'] = pd.to_datetime(Y_df['ds'])
S = S.reset_index(names="unique_id")

Y_test_df  = Y_df.groupby('unique_id').tail(24)
Y_train_df = Y_df.drop(Y_test_df.index)
Y_test_df_pl  = pl.from_pandas(Y_test_df)
Y_train_df_pl = pl.from_pandas(Y_train_df)

fcst = StatsForecast(
    models=[AutoETS(season_length=12, model='AAZ')],
    freq='1m',
    n_jobs=-1
)
Y_hat_df = fcst.forecast(df=Y_train_df_pl, h=24)

# Plot prediction difference of different aggregation
# Levels Country, Country/Region, Country/Gender/Region ...
hplots = HierarchicalPlot(S=S, tags=tags)

hplots.plot_hierarchical_predictions_gap(
    Y_df=Y_hat_df, models='AutoETS',
    xlabel='Month', ylabel='Predictions',
)
```

## External Forecast Adapters

### `samples_to_quantiles_df`

```python
samples_to_quantiles_df(samples, unique_ids, dates, quantiles=None, level=None, model_name='model', id_col='unique_id', time_col='ds', backend='pandas')
```

Transform Random Samples into HierarchicalForecast input.

Auxiliary function to create compatible HierarchicalForecast input `Y_hat_df` dataframe.

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`samples` | <code>[ndarray](#numpy.ndarray)</code> | Samples from forecast distribution of shape [n_series, n_samples, horizon]. | *required*
`unique_ids` | <code>[Sequence](#collections.abc.Sequence)\[[str](#str)\]</code> | Unique identifiers for each time series. | *required*
`dates` | <code>[list](#list)\[[str](#str)\]</code> | list of forecast dates. | *required*
`quantiles` | <code>[Optional](#typing.Optional)\[[list](#list)\[[float](#float)\]\]</code> | Alternative to level, quantiles to estimate from y distribution [0., 1.]. Default is None. | <code>None</code>
`level` | <code>[Optional](#typing.Optional)\[[list](#list)\[[int](#int)\]\]</code> | Probability levels for prediction intervals [0,100]. Default is None. | <code>None</code>
`model_name` | <code>[str](#str)</code> | Name of forecasting model. Default is "model". | <code>'model'</code>
`id_col` | <code>[str](#str)</code> | column that identifies each serie. Default is 'unique_id'. | <code>'unique_id'</code>
`time_col` | <code>[str](#str)</code> | column that identifies each timestep, its values can be timestamps or integers. Default is 'ds'. | <code>'ds'</code>
`backend` | <code>[str](#str)</code> | backend to use for the output dataframe, either 'pandas' or 'polars'. Default is 'pandas'. | <code>'pandas'</code>

**Returns:**

Type | Description
---- | -----------
<code>[tuple](#tuple)\[[list](#list)\[[float](#float)\], [FrameT](#narwhals.typing.FrameT)\]</code> | tuple\[list[float], FrameT\]: quantiles and Y_hat_df
quantiles: quantiles to estimate from y distribution [0., 1.].
Y_hat_df: DataFrame with base quantile forecasts with columns ds and models to reconcile indexed by unique_id.
